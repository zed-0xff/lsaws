#!/usr/bin/env ruby
require 'aws-sdk-ec2'
require 'terminal-table'
require 'optparse'

class Lsaws
  SUPPORTED_FORMATS = %w'table yaml json json-stream text'.sort
  DEFAULT_FORMAT    = :table

  def initialize argv
    @options = {
      format: DEFAULT_FORMAT,
      header: true,
      filters: {},
      only_cols: [],
    }
    @commands = option_parser.parse!(argv)
  end

  def option_parser
    @option_parser ||=
      OptionParser.new do |opt|
        opt.on('-o', '--output FMT', SUPPORTED_FORMATS, "Format: #{SUPPORTED_FORMATS.join('/')}") do |f|
          @options[:format] = f.to_sym
        end
        opt.on('--tags', 'Show tags') { @options[:show_tags] = true }
        opt.on('-v', '--verbose', 'Verbose output') { @options[:verbose] = true }
        opt.on('--no-header', 'Suppress header') { @options[:header] = false }
        opt.on('-f', '--filter K=V', 'Add filter') { |o| @options[:filters].merge!(Hash[*o.split("=",2)]) }
        opt.on('--only C', 'Show only specified column(s)') { |o| @options[:only_cols] << o }
      end
  end

  SUPPORTED_ENTITIES = {
    ami: {
      query:  Proc.new{ |params| Aws::EC2::Client.new.describe_images(params.merge(owners: ['self'])) },
      cols: [
        :image_id,
        {name: Proc.new{ |entity| entity.tags.find { |tag| tag.key == "Name" }&.value }},
        :creation_date,
      ],
      result_keys: [:images],
    },
    ec2: {
      query:  Proc.new{ |params| Aws::EC2::Client.new.describe_instances(params) },
      default_filter: { name: 'instance-state-name', values: ['pending', 'running', 'shutting-down', 'stopping'] },
      cols: [
        :instance_id,
        {name: Proc.new{ |entity| entity.tags.find { |tag| tag.key == "Name" }&.value }},
        :vpc_id,
        :private_ip_address,
        :image_id,
      ],
      result_keys: [:reservations, :instances],
    }
  }

  def _prepare_entities(type)
    edef = SUPPORTED_ENTITIES[type]
    raise "unknown entity type: #{type}" unless edef
    params = {}
    if @options[:filters].any?
      params[:filters] = @options[:filters].map{ |k,v| {name: k, values: [v]} }
    else
      params[:filters] = [edef[:default_filter]] if edef[:default_filter]
    end
    result = edef[:query].call(params)
    edef[:result_keys].each do |key|
      if result.is_a?(Array)
        result = result.map(&key).flatten
      else
        result = result.send(key)
      end
    end
    col_defs = {}
    edef[:cols].each do |r|
      case r
      when Symbol
        col_defs[r] = Proc.new{ |entity| entity.send(r) }
      when Hash
        col_defs.merge!(r)
      end
    end
    col_defs[:tags] = _convert_tags_proc if @options[:show_tags]
    if @options[:only_cols].any?
      col_defs.delete_if{ |k,v| !@options[:only_cols].include?(k.to_s) }
    end
    result.map do |entity|
      yield entity, col_defs
    end
  end

  def entities2hashes type
    _prepare_entities(type) do |entity, col_defs|
      Hash[col_defs.keys.map(&:to_s).zip col_defs.values.map{ |p| p.call(entity) }]
    end
  end

  def entities2arrays type
    hdr = nil
    rows = _prepare_entities(type) do |entity, col_defs|
      hdr ||= col_defs.keys.map(&:to_s)
      col_defs.values.map{ |p| p.call(entity) }
    end
    if rows.any?
      [hdr] + rows
    else
      []
    end
  end

  def _convert_tags_proc
    case @options[:format]
    when :table, :text
      Proc.new{ |entity| entity.tags.map{ |tag| "#{tag.key}=#{tag.value}" }.join(", ") }
    else
      Proc.new{ |entity| Hash[*entity.tags.map{ |tag| [tag.key, tag.value] }.flatten] }
    end
  end

  def process_command cmd
    case @options[:format]
    when :text, :table
      rows = entities2arrays(cmd)
      return unless rows.any?
      hdr = rows.shift
      table = 
        if @options[:header]
          Terminal::Table.new rows: rows, headings: hdr
        else
          Terminal::Table.new rows: rows
        end
      if @options[:format] == :text
        table.style = { border_x: '', border_y: '', border_i: '', border_top: false, border_bottom: false }
      else
        table.style = { border: :unicode_round }
      end
      puts table
    when :json
      require 'json' unless defined?(JSON)
      rows = entities2hashes(cmd)
      puts rows.to_json
    when :'json-stream'
      require 'json' unless defined?(JSON)
      rows = entities2hashes(cmd)
      rows.each do |row|
        puts row.to_json
      end
    when :yaml
      require 'yaml' unless defined?(YAML)
      rows = entities2hashes(cmd)
      puts rows.to_yaml
    else
      STDERR.puts "[!] unknown format: #{@options[:format]}"
      exit 1
    end
  end

  def run!
    if @commands.empty?
      puts option_parser.help
      return
    end
    @commands.each do |cmd|
      process_command cmd.to_sym
    end
  end
end

if __FILE__ == $0
  Lsaws.new(ARGV).run!
end
