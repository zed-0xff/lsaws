#!/usr/bin/env ruby
require 'terminal-table'
require 'optparse'
require 'yaml'

class Lsaws
  SUPPORTED_FORMATS = %w'table yaml json json-stream text'.sort
  DEFAULT_FORMAT    = :table

  def initialize argv
    @options = {
      format: DEFAULT_FORMAT,
      header: true,
      filters: {},
      only_cols: [],
    }
    @commands = option_parser.parse!(argv)
  end

  def option_parser
    @option_parser ||=
      OptionParser.new do |opt|
        opt.banner = "Usage: lsaws [options] <sdk> [entity]"

        opt.on('-o', '--output FMT', SUPPORTED_FORMATS, "Format: #{SUPPORTED_FORMATS.join('/')}") do |f|
          @options[:format] = f.to_sym
        end
        opt.on('--tags', 'Show tags') { @options[:show_tags] = true }
        opt.on('-v', '--verbose', 'Verbose output') { @options[:verbose] = true }
        opt.on('--no-header', 'Suppress header') { @options[:header] = false }
        opt.on('-f', '--filter K=V', 'Add filter') { |o| @options[:filters].merge!(Hash[*o.split("=",2)]) }
        opt.on('--only C', 'Show only specified column(s)') { |o| @options[:only_cols] << o }

        opt.separator "\nSupported SDKs & entities:"
        SUPPORTED_ENTITIES.each do |sdk, entities|
          opt.separator "  #{sdk}\n    #{(entities.keys - ['default']).sort.join(", ")}"
        end
      end
  end

  SUPPORTED_ENTITIES = YAML::load_file(File.expand_path(__FILE__) + ".yml")

  def _prepare_entities(sdk, type)
    edef = SUPPORTED_ENTITIES[sdk][type]
    if edef.is_a?(String)
      type = edef
      edef = SUPPORTED_ENTITIES[sdk][type]
    end
    raise "unknown entity type: #{type}" unless edef
    require(edef['require'] || "aws-sdk-#{sdk}")

    method_name = edef['method'] || "describe_#{type}"
    params = edef['default_params'] || {}
    if @options[:filters].any?
      params[:filters] = @options[:filters].map{ |k,v| {name: k, values: [v]} }
    else
      params[:filters] = [edef["default_filter"]] if edef["default_filter"]
    end

    client_class = edef['client_class'] || "Aws::#{sdk.upcase}::Client"
    client = Kernel.const_get(client_class).new
    results = client.send(method_name, params)

    edef["result_keys"] ||= [type]
    edef["result_keys"].each do |key|
      if results.is_a?(Array)
        results = results.map(&key.to_sym).flatten
      else
        results = results.send(key)
      end
    end
    col_defs = {}
    edef["cols"].each do |r|
      case r
      when String
        col_defs[r] = Proc.new{ |entity| entity.send(r) }
      when Hash
        col_defs.merge!(r)
      else
        raise "unexpected #{r.inspect}"
      end
    end
    col_defs["tags"] = _convert_tags_proc if @options[:show_tags]
    if @options[:only_cols].any?
      col_defs.delete_if{ |k,v| !@options[:only_cols].include?(k.to_s) }
    end
    if results.any? && !results.first.respond_to?(:name)
      results.first.class.class_eval do
        def name
          tags.find { |tag| tag.key == "Name" }&.value
        end
      end
    end
    results.map do |entity|
      yield entity, col_defs
    end
  end

  def entities2hashes sdk, type
    _prepare_entities(sdk, type) do |entity, col_defs|
      Hash[col_defs.keys.map(&:to_s).zip col_defs.values.map{ |p| p.call(entity) }]
    end
  end

  def entities2arrays sdk, type
    hdr = nil
    rows = _prepare_entities(sdk, type) do |entity, col_defs|
      hdr ||= col_defs.keys.map(&:to_s)
      col_defs.values.map{ |p| p.call(entity) }
    end
    if rows.any?
      [hdr] + rows
    else
      []
    end
  end

  def _convert_tags_proc
    case @options[:format]
    when :table, :text
      Proc.new{ |entity| entity.tags.map{ |tag| "#{tag.key}=#{tag.value}" }.join(", ") }
    else
      Proc.new{ |entity| Hash[*entity.tags.map{ |tag| [tag.key, tag.value] }.flatten] }
    end
  end

  def process_command sdk, type = 'default'
    case @options[:format]
    when :text, :table
      rows = entities2arrays(sdk, type)
      return unless rows.any?
      hdr = rows.shift
      table = 
        if @options[:header]
          Terminal::Table.new rows: rows, headings: hdr
        else
          Terminal::Table.new rows: rows
        end
      if @options[:format] == :text
        table.style = { border_x: '', border_y: '', border_i: '', border_top: false, border_bottom: false }
      else
        table.style = { border: :unicode_round }
      end
      puts table
    when :json
      require 'json' unless defined?(JSON)
      rows = entities2hashes(cmd)
      puts rows.to_json
    when :'json-stream'
      require 'json' unless defined?(JSON)
      rows = entities2hashes(cmd)
      rows.each do |row|
        puts row.to_json
      end
    when :yaml
      rows = entities2hashes(cmd)
      puts rows.to_yaml
    else
      STDERR.puts "[!] unknown format: #{@options[:format]}"
      exit 1
    end
  end

  def run!
    case @commands.size
    when 1, 2
      process_command *@commands
    else
      puts option_parser.help
      return
    end
  end
end

if __FILE__ == $0
  Lsaws.new(ARGV).run!
end
